#include <iostream>//подключение библиотек
#include <vector>
#include <string>
#include <algorithm>
#include <fstream>
#include <map>
#include <iterator>
#include <stdio.h>
#include <cctype>
#include <locale.h>
#include <Windows.h>
#include <conio.h>
using namespace std;//выбор пространства имен
 
string FinalBeautify(string word) {//фнукция очистки слов от символов коца предожения
	const std::string puncts = ".?!";//набор всех знаков препинания, которые следует очистить
	string output;//переменная результатат
	for (const auto& ch : word) {//для каждого символа из слова
		bool found = false;//переменная совпадения
		for (const auto& p : puncts) {//для каждого символа набора знаков препинания
			if (ch == p) { //если символ из слова совпадает с символом из набора знаков препинания
				found = true;// присваивание совпадению истины
				break;//выход из цикла
			}
		}
		if (!found)//если не найдено
			output += ch;//добавляем символ к слову
	}
	return output;//возврат получившегося слова
}
 
string Beautify(string word) {//функция очистки слов от знаков препинания (кроме точки, восклицательного знака и вопросительного знака)
	const string puncts = " [];',/{}:\"><`~-_()"; //набор всех знаков препинания, которые следует очистить
	string output; //переменная результатат
	for (const auto& ch : word) //для каждого символа из слова 
	{
		bool found = false;//переменная совпадения
		for (const auto& p : puncts) //для каждого символа набора знаков препинания
		{
			if (ch == p) //если символ из слова совпадает с символом из набора знаков препинания
			{
				found = true; // присваивание совпадению истины
				break; //выход из цикла
			}
		}
		if (!found) //если не найдено
			output += ch; //добавляем символ к слову
	}
	return output; //возврат получившегося слова
}
 
multimap<int, string> Sort(map<string, int> verbs) {//фнукция сорировки словаря где содержатся пары {глагол : количество употреблений данного глагола в тексте}
	multimap<int, string> res;//создание контейнера для результатата
	for (pair<string, int> pair : verbs) {
		res.insert({ pair.second, pair.first });//запись из map в multimap и получение multimap отсортировнного по количеству повторений 
	}
	return res;//возврат отсортированного контейнера
}
 
int SentenceNum(int num, string word) {//счетчк предложений
	if (word[word.size() - 1] == '.' || word[word.size() - 1] == '!' || word[word.size() - 1] == '?')//если копия слова заканчивается точкой запятой или восклицательным знакомм
		num++;//количество увеличивается на 1
	return num;//возврат количества
}
 
bool DefineVerb2(string word) {//функция определения глаголов оканчивающихся на ить и состоящих из 4х букв
	vector<string> verbs = { "бить", "быть", "вить", "выть", "дать", "деть", "дуть", "есть", "шить ",
							"жать", "жить", "лить", "мыть", "мять", "ныть", "петь", "пить", "рыть" };//набор всех существующих таких глаголов
	vector<string>::iterator it;//создаем итератор
	bool res;//логческая переменная реультата
 
	it = find(verbs.begin(), verbs.end(), word);//ищем слово в наборе глаголов
	it != verbs.end() ? res = true : res = false;//принятие решения о части речи
	return res;//возврат результата
}
 
bool DefineVerb(string word) {//функция определения глаголов
	vector<string> endings1 = { "ила", "ыла", "ена", "ейте", "уйте", "юйте", "ите", "или", "ыли", "ей", "уй", "юй", "ил", "ыл", "им", "ым", "ен",
								"ило", "ыло", "ено", "ят", "ут", "ует", "уют", "ит", "ыт", "ены", "ишь", "ую", "ю", "ла", "ете","ёте", "ите", "йте",
								"ли", "ай", "яй", "л", "ем", "ло", "ет", "ют", "ть", "ешь", "ёшь", "ться", "тся" }; //набор типичных окончаний глаголов
	vector<string> endings2 = { "ее","ие","ые","ое","ими","ыми","ей","ий","ый","ой","ем","им","ым","ом",
								"его","ого","ему","ому","их","ых","ую","юю","ая","яя","ою","ею" }; //наборы типичных окончаний не глаголов
	vector<string> endings3 = { "ивш","ывш","ующ","ем","нн","вш","ющ","ущи","ющи","ящий","щих","щие","ляя" };
	vector<string> endings4 = { "а","ев","ов","ье","иями","ями","ами","еи","ии","и","ией","ей","ой","ий","й","иям","ям","ием","ем",
								"ам","ом","о","у","ах","иях","ях","ы","ь","ию","ью","ю","ия","ья","я","ок", "мва", "яна","ег","ги","га","сть","сти" };
	vector<string> endings5 = { "чно", "еко", "соко", "боко", "роко", "имо", "мно", "жно", "жко","ело","тно","льно","здо","зко","шо","хо","но" };
 
	bool IsVerb = false;//логическая переменная глагол или нет
	vector<string>::iterator it;//создаем набор итераторов для каждого набора окончаний
	vector<string>::iterator it2;
	vector<string>::iterator it3;
	vector<string>::iterator it4;
	vector<string>::iterator it5;
	int len;//пременная длины слова
 
	if (word.length() < 3)//если слово короче 3 букв
		return IsVerb;//возвращаем ложь так как глаголов из 1 или 2 букв не бывает
	else {//иначе
 
		word.length() < 4 ? len = 3 : len = 4;//присваиваем значения переменной длины в зависимости от лины
 
		for (int i = len; i > 0; --i) {//берем срезы слова и ищем окончания в наборах
			string ending = word.substr(word.length() - i, i);
			it = find(endings1.begin(), endings1.end(), ending);
			it2 = find(endings2.begin(), endings2.end(), ending);
			it3 = find(endings3.begin(), endings3.end(), ending);
			it4 = find(endings4.begin(), endings4.end(), ending);
			it5 = find(endings5.begin(), endings5.end(), ending);
 
			if (it != endings1.end() && it2 == endings2.end() && it3 == endings3.end() && it4 == endings4.end() && it5 == endings5.end()) {//если находим в слове окончание из первого набора и не находим окончания из остальных наборов
				ending == "ть" && word.length() == 4 ? IsVerb = DefineVerb2(word) : IsVerb = true;//обработка слова из 4х букв с окончанием на "ть" специальной функцией
				ending == "ишь" && word.length() == 4 ? IsVerb = false : IsVerb = true;//обработка особых случаев
				word == "или" || word == "если" ? IsVerb = false : IsVerb = true;
				break;//выход из цикла
			}
		}
		return IsVerb;//возврат результата
	}
}
 
 
string Str_tolower(string word) { //функция понижения регистра
	transform(word.begin(), word.end(), word.begin(),
	[](unsigned char c) { return tolower(c); }
	);
	return word;//возвращение результата
}
 
 
string Open() { //функция открытия файла исходных данных
	string filename; //переменная имени фалйа
	cout << "Пожалуйста введите название файла исходных данных: ";
	cin >> filename; //считываем название файла исходных данных
	ifstream in; //установление потока для чтения исходного файла
	filename= filename + ".txt"; //добавляем расширение для корректного определения типа файла
 
 
	in.open(filename); //открываем файл исходных данных
 
	while (!in.is_open()) { //если файл не открылся
		cout << "Такого файла не существует, введите другое название:";
		cin >> filename; //ввод нового названия файла
		filename = filename + ".txt";//добавляем расширение для корректного определения типа файла
		in.open(filename);//открываем файл исходных данных
	}
	in.close(); //закрываем файл
	return filename; //возвращаем корреткное название файла исходных данных, введенное пользователем
}
 
bool IsEmpty(string filename) {//функция проверки наличия информации в файле
	ifstream in; //установление потока для чтения файла
	string word; //переменная  куда считываем из файла
 
	in.open(filename); //открываем файл
	in >> word; //считываем информацию из файла в переменную
	if (word == "") { //если переменная пуста
 
		in.close();//закрытие файла
		return true; //возвращаем истину
	}
	return false; //возвращаем ложь
}
 
 
string CheckFile() { //функция содания и открытия файла выходных данных
	string filename;//переменная имени фалйа
	cout << "Введите название файла выходных данных: ";
	cin >> filename;//считываем название файла исходных данных
	filename = filename + ".txt";//добавляем расширение для корректного определения типа файла
 
	ifstream out; //установление потока для чтения файла
	out.open(filename); //открываем файл выходных данных
	while (out.is_open()) { //если открылся
		out.close(); //закрыие файла
		cout << "Введенный вами файл уже существует, выберите другой: ";
		cin >> filename;//считываем название файла исходных данных
		filename = filename + ".txt";//добавляем расширение для корректного определения типа файла
		out.open(filename); //открытие файла
	}
	return filename;//возвращаем корреткное название файла выходных данных, введенное пользователем
}
 
 
int main() {
	setlocale(LC_ALL, "Russian"); //включение русского языка в консоли
	SetConsoleOutputCP(1251);
	SetConsoleCP(1251);
 
	map<string, int> verbs_count; //словарь в котором хранятся пары {глагол : сколько данных глаголов в тексте}
	map<string,vector<int>> sentences_count; //словарь в котором хранятся пары {глагол : вектор, в котором хранятся номера предложений, в которых встретился данный глагол}
	vector<string> verbs; //вектор в котором хранятся найденные глаголы
	vector<string>::iterator it; //итератор для вектора из строк 
	vector<int>::iterator it1; // итератор для вектора из  целых чисел
	string filename; //переменная с названием входного  файлов
	string output;//переменная с названием выходного  файлов
	ifstream in; //установление потока для чтения исходного файла
 
	vector<string> sentences; //вектор, в котором хранятся предложения
	string sentence; //строка в которой будет храниться конкретное предложение
	int brackets_count; //переменная, которая считает количество ковычек вида {"} в предложении
	int brackets_count_b; //переменная, которая считает количество ковычек вида {«} в предложении
	int brackets_count_e; //переменная, которая считает количество ковычек вида {»} в предложении
	bool IsQuote; //логическая переменная, которая отвечает за то, является ли данное предложение прямой речью
 
	cout << "Вас приветсвует программа для поиска глаголов из текстового файла!" << '\n'; //вывод приветствия, информации и инструкции пользователю
	cout << "ВНИМАНИЕ! Программа работает с текстовыми файлами ТОЛЬКО в кодировке ANSI! \n";
	cout << "\n";
	cout << "Для ввода названия файла исходных данных нажмите любую клавишу." << '\n' << "Для выхода нажмите Escape " << '\n'; 
	cout << "\n";
	char ans; //переменная для выбора 
	switch (ans = _getch()) { //оператор выбора
	case 27: {exit(0);//Если нажат Escape, то выход из программы
	};
	};
	system("cls"); //очищение экрана
	filename = Open(); //вызов функции Open и присваивание переменной названия файла ее возвращаемого значения
 
	while (IsEmpty(filename)) {//если файл пуст
		cout << "Ваш файл пуст, выберите другой" << '\n';
		filename = Open();//вызов процедуры Open и присваивание переменной названия файла ее возвращаемого значения
	}
	cout << '\n' << "Глаголы будут выписаны из файла: " << filename << '\n' << '\n';//вывод информации
 
	cout << "Для вывода результатов в файл нажмите любую клавишу, для выхода нажмите Escape ";//вывод инструкции пользователю
 
	ans = _getch(); //считывание в переменную нажатой клавиши
	if (ans == 27) { //Если выбран Escape
		exit(0);//выход из программы
	}
 
	system("cls"); //очистка экрана
	output = CheckFile(); //вызов процедуры CheckFile и присваивание переменной названия файла ее возвращаемого значения
	cout << '\n' << "Глаголы будут выведены в файл: " << output << '\n' << '\n';//вывод информации
 
	in.open(filename);//открываем файл исходных данных
	vector<string> words; //создаем вектор строк для записи в него слов
	string word;//создаем строку в которой будем хранить конкретное слово
	int sentence_num = 1; //присваиваем начальный номер предложения 1
 
	while (in >> word) {//читаем последовательность символов и записываем ее в переменную word (последовательность любых символов до пробельного знака)
		sentence += " " + word; //к текушему предложению присоединяем пробел плюс слово
		brackets_count = std::count(sentence.begin(), sentence.end(), '"'); //считаем количество разного вида кавычек(это обрабатывает случаи, когда предложение содержит прямую речь)
		brackets_count_b = std::count(sentence.begin(), sentence.end(), '«');
		brackets_count_e = std::count(sentence.begin(), sentence.end(), '»');
		if (brackets_count % 2 == 0 && brackets_count_b == brackets_count_e)
			IsQuote = false;
		else
			IsQuote = true;
		if ((sentence.back() == '.' || sentence.back() == '!' || sentence.back() == '?') && word != "т.к." && word != "т.д." && word != "т.е." && word != "др." && !IsQuote) {//если предложение закончено
			sentences.push_back(sentence); //записываем его в вектор с предложениями
			sentence.clear();//очищаем переменную предложения
		}
 
		if (word.size() > 1) {//если размер слова больше единицы (это не знак препинания отделенный пробелом)
			word = Beautify(word); //обработка функцией Beautify
			word = Str_tolower(word);//обработка функцией Str_tolower
			words.push_back(word);//добавляем обработанный word в вектор со словами words
		}
	}
 
	in.close();//закрываем файл исходных данных
	for (int i = 0; i < words.size(); ++i) {//для каждого слова из вектора words
		bool IsVerb;//логическая переменная
		string word_copy = words[i];//создаем копию этого слова
		if (words[i][words[i].size() - 1] == '.' || '!' || '?') //если слово заканчивается на вопросительный, восклицательный знак или точку
			words[i] = FinalBeautify(words[i]); //обработка функцией FinalBeautify
		IsVerb = DefineVerb(words[i]); //применяем к слову логическую функцию DefineVerb(), результат который записываем в логическую переменную IsVerb
 
 
		if (IsVerb) {//если глагол
 
			verbs_count[words[i]] += 1;//увеличиваем значение словаря по ключу равному данному слову на единицу (в нем мы считаем количество встреченных одинаковых глаголов)
			it = find(verbs.begin(), verbs.end(), words[i]); //ищем глагол в векторе с глаголами 
			if (it == verbs.end())//если не находим 
				verbs.push_back(words[i]);//добавляем его в конец вектора
 
			it1 = find(sentences_count[words[i]].begin(), sentences_count[words[i]].end(), sentence_num); //ищем в векторе который является значением по ключу данного слова номер текущего предложения
			if (it1 == sentences_count[words[i]].end())//если его там нет
				sentences_count[words[i]].push_back(sentence_num);//добавляем номер предложения в конец вектора
		}
		sentence_num = SentenceNum(sentence_num, word_copy); //определяем номер предложения у следующего слова функцией SentenceNum()
	}
	multimap<int, string> sorted_verbs;//создаем контейнер для записи в него результата 
 
	sorted_verbs = Sort(verbs_count);//приравнием результат Sort() в multimap который создали для записи в него результата 
 
	multimap<int, string>::reverse_iterator it_r = sorted_verbs.rbegin();// создаем итератор для multimap который создали для записи в него результата
 
		ofstream out; //через поток выходного файла
		out.open(output);//открываем файл выходных данных 
		out << "Глаголы: " << '\n';
		while (it_r != sorted_verbs.rend()) {//пока итератор не достиг конца sorted_verbs
			out << it_r->second << " : " << it_r->first << " слов(a) встретились в предложении(ях) под номерами: ";//выводим для каждого его элемента информацию которую мы хранили в его ключе 
			for (int i = 0; i < sentences_count[it_r->second].size(); i++) {
				out << sentences_count[it_r->second][i] << " ";//и выводим информацию которую мы хранили в словаре sentences_count
			}
			out << '\n';
			it_r++;
		}
		out << "Исходные предложения:" << '\n';// исходный текст с номерами предложений
		for (int i = 0; i < sentences.size(); ++i)
			out << i + 1 << ")" << sentences[i] << '\n'; //выводим предложения которые мы сохранили в векторе sentences
		out.close();//закрываем файл выходных данных
 
	system("pause");//остановка в конце
}